{
  "version": 3,
  "sources": ["../../dexie-react-hooks/src/useObservable.ts", "../../dexie-react-hooks/src/useLiveQuery.ts", "../../dexie-react-hooks/src/usePermissions.ts"],
  "sourcesContent": ["import React from 'react';\nexport interface InteropableObservable<T> {\n  subscribe(\n    onNext: (x: T) => any,\n    onError?: (error: any) => any\n  ): (() => any) | { unsubscribe(): any };\n  getValue?(): T; // For BehaviorSubject\n  hasValue?(): boolean; // For liveQuery observable returning false until a value is available\n}\n\nexport function useObservable<T, TDefault>(\n  observable: InteropableObservable<T>\n): T | undefined;\nexport function useObservable<T, TDefault>(\n  observable: InteropableObservable<T>,\n  defaultResult: TDefault\n): T | TDefault;\nexport function useObservable<T>(\n  observableFactory: () => InteropableObservable<T>,\n  deps?: any[]\n): T | undefined;\nexport function useObservable<T, TDefault>(\n  observableFactory: () => InteropableObservable<T>,\n  deps: any[],\n  defaultResult: TDefault\n): T | TDefault;\nexport function useObservable<T, TDefault>(\n  observableFactory:\n    | InteropableObservable<T>\n    | (() => InteropableObservable<T>),\n  arg2?: any,\n  arg3?: any\n) {\n  // Resolve vars from overloading variants of this function:\n  let deps: any[];\n  let defaultResult: TDefault;\n  if (typeof observableFactory === 'function') {\n    deps = arg2 || [];\n    defaultResult = arg3;\n  } else {\n    deps = [];\n    defaultResult = arg2;\n  }\n\n  // Create a ref that keeps the state we need\n  const monitor = React.useRef({\n    hasResult: false,\n    result: defaultResult as T | TDefault,\n    error: null as any,\n  });\n  // We control when component should rerender. Make triggerUpdate\n  // as examplified on React's docs at:\n  // https://reactjs.org/docs/hooks-faq.html#is-there-something-like-forceupdate\n  const [_, triggerUpdate] = React.useReducer((x) => x + 1, 0);\n\n  // Memoize the observable based on deps\n  const observable = React.useMemo(() => {\n    // Make it remember previous subscription's default value when\n    // resubscribing.\n    const observable =\n      typeof observableFactory === 'function'\n        ? observableFactory()\n        : observableFactory;\n    if (!observable || typeof observable.subscribe !== 'function') {\n      if (observableFactory === observable) {\n        throw new TypeError(\n          `Given argument to useObservable() was neither a valid observable nor a function.`\n        );\n      } else {\n        throw new TypeError(\n          `Observable factory given to useObservable() did not return a valid observable.`\n        );\n      }\n    }\n\n    if (!monitor.current.hasResult &&\n        typeof window !== 'undefined' // Don't do this in SSR\n       ) {\n      // Optimize for BehaviorSubject and other observables implementing getValue():\n      if (typeof observable.hasValue !== 'function' || observable.hasValue()) {\n        if (typeof observable.getValue === 'function') {\n          monitor.current.result = observable.getValue();\n          monitor.current.hasResult = true;\n        } else {\n          // Find out if the observable has a current value: try get it by subscribing and\n          // unsubscribing synchronously\n          const subscription = observable.subscribe((val) => {\n            monitor.current.result = val;\n            monitor.current.hasResult = true;\n          });\n          // Unsubscribe directly. We only needed any synchronous value if it was possible.\n          if (typeof subscription === 'function') {\n            subscription();\n          } else {\n            subscription.unsubscribe();\n          }\n        }\n      }\n    }\n    return observable;\n  }, deps);\n\n  // Integrate with react devtools:\n  React.useDebugValue(monitor.current.result);\n\n  // Subscribe to the observable\n  React.useEffect(() => {\n    const subscription = observable.subscribe(\n      (val) => {\n        const { current } = monitor;\n        if (current.error !== null || current.result !== val) {\n          current.error = null;\n          current.result = val;\n          current.hasResult = true;\n          triggerUpdate();\n        }\n      },\n      (err) => {\n        const { current } = monitor;\n        if (current.error !== err) {\n          current.error = err;\n          triggerUpdate();\n        }\n      }\n    );\n    return typeof subscription === 'function'\n      ? subscription // Support observables that return unsubscribe directly\n      : subscription.unsubscribe.bind(subscription);\n  }, deps);\n\n  // Throw if observable has emitted error so that\n  // an ErrorBoundrary can catch it\n  if (monitor.current.error) throw monitor.current.error;\n\n  // Return the current result\n  return monitor.current.result;\n}\n", "import { liveQuery } from 'dexie';\nimport { useObservable } from './useObservable';\n\nexport function useLiveQuery<T>(\n  querier: () => Promise<T> | T,\n  deps?: any[]\n): T | undefined;\nexport function useLiveQuery<T, TDefault>(\n  querier: () => Promise<T> | T,\n  deps: any[],\n  defaultResult: TDefault\n): T | TDefault;\nexport function useLiveQuery<T, TDefault>(\n  querier: () => Promise<T> | T,\n  deps?: any[],\n  defaultResult?: TDefault\n): T | TDefault {\n  return useObservable(\n    () => liveQuery(querier),\n    deps || [],\n    defaultResult as TDefault\n  );\n}\n", "import { Dexie } from 'dexie';\nimport { useObservable } from './useObservable';\n//import type { KeyPaths, TableProp } from 'dexie'; // Issue #1725 - not compatible with dexie@3.\n// Workaround: provide these types inline for now. When dexie 4 stable is out, we can use the types from dexie@4.\nexport type KeyPaths<T> = {\n  [P in keyof T]: \n    P extends string \n      ? T[P] extends Array<infer K>\n        ? K extends object // only drill into the array element if it's an object\n          ? P | `${P}.${number}` | `${P}.${number}.${KeyPaths<K>}` \n          : P | `${P}.${number}`\n        : T[P] extends (...args: any[]) => any // Method\n           ? never \n          : T[P] extends object \n            ? P | `${P}.${KeyPaths<T[P]>}` \n            : P \n      : never;\n}[keyof T];\nexport type TableProp<DX extends Dexie> = {\n  [K in keyof DX]: DX[K] extends {schema: any, get: any, put: any, add: any, where: any} ? K : never;\n}[keyof DX] & string;\n\n\ninterface DexieCloudEntity {\n  table(): string;\n  realmId: string;\n  owner: string;\n}\n\nexport interface PermissionChecker<T, TableName extends string> {\n  add(...tableNames: TableName[]): boolean;\n  update(...props: KeyPaths<T>[]): boolean;\n  delete(): boolean;\n}\n\nexport function usePermissions<T extends DexieCloudEntity>(\n  entity: T\n): PermissionChecker<\n  T,\n  T extends { table: () => infer TableName } ? TableName : string\n>;\nexport function usePermissions<\n  TDB extends Dexie,\n  T\n>(db: TDB, table: TableProp<TDB>, obj: T): PermissionChecker<T, TableProp<TDB>>;\nexport function usePermissions(\n  firstArg:\n    | Dexie\n    | {\n        realmId?: string;\n        owner?: string;\n        table?: () => string;\n        readonly db?: Dexie;\n      },\n  table?: string,\n  obj?: { realmId?: string; owner?: string }\n) {\n  if (!firstArg)\n    throw new TypeError(\n      `Invalid arguments to usePermissions(): undefined or null`\n    );\n  let db: Dexie;\n  if (arguments.length >= 3) {\n    if (!('transaction' in firstArg)) {\n      // Using ducktyping instead of instanceof in case there are multiple Dexie modules in app.\n      // First arg is  ensures first arg is a Dexie instance\n      throw new TypeError(\n        `Invalid arguments to usePermission(db, table, obj): 1st arg must be a Dexie instance`\n      );\n    }\n    if (typeof table !== 'string')\n      throw new TypeError(\n        `Invalid arguments to usePermission(db, table, obj): 2nd arg must be string`\n      );\n    if (!obj || typeof obj !== 'object')\n      throw new TypeError(\n        `Invalid arguments to usePermission(db, table, obj): 3rd arg must be an object`\n      );\n    db = firstArg;\n  } else {\n    if (firstArg instanceof Dexie)\n      throw new TypeError(\n        `Invalid arguments to usePermission(db, table, obj): Missing table and obj arguments.`\n      );\n\n    if (\n      typeof firstArg.table === 'function' &&\n      typeof firstArg.db === 'object'\n    ) {\n      db = firstArg.db!;\n      obj = firstArg;\n      table = firstArg.table();\n    } else {\n      throw new TypeError(\n        `Invalid arguments to usePermissions(). ` +\n          `Expected usePermissions(entity: DexieCloudEntity) or ` +\n          `usePermissions(db: Dexie, table: string, obj: DexieCloudObject)`\n      );\n    }\n  }\n  if (!('cloud' in db))\n    throw new Error(\n      `usePermissions() is only for Dexie Cloud but there's no dexie-cloud-addon active in given db.`\n    );\n  if (!('permissions' in (db as any).cloud))\n    throw new Error(`usePermissions() requires a newer version of dexie-cloud-addon. Please upgrade it.`)\n  return useObservable(\n    // @ts-ignore\n    () => db.cloud.permissions(obj, table),\n    [obj.realmId, obj.owner, table]\n  );\n}\n"],
  "mappings": "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",
  "names": ["React", "observable"]
}
